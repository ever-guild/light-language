%{
open ParserModule
open type LHMachine.Expr

// EFunc of arg:Name * body:Expr
// ["x","y","z"], body ->
//   --> EFunc ("x", EFunc ("y", EFunc ("z", body)))
let rec unfoldFunction args body =
    match args with
    | [x] ->
        EFunc (x, body)
    | h :: t ->
        EFunc (h, unfoldFunction t body)
%}

%start start

%token <int> INT
%token <string> UIDENT
%token <string> LIDENT
%token <string> IDENT
%token <string> STRING
%token MODULE TYPEDEF OF IF THEN ELSE HANDLER LET RECURSIVE IN
%token EQ GT PLUS MINUS SEMICOLON VBAR STAR COLON COMMA EOF
%token LEFT_BRACE RIGHT_BRACE LEFT_BRACKET RIGHT_BRACKET

%type <ParserModule.Module option> start

%nonassoc LET

%%

start:
  | EOF { None }
  | modle { Some $1 }

// =================================================
// Single variable declaration.
// "x : int", "ud : UserData"
// =================================================
varDecl:
  | LIDENT COLON LIDENT    { ($1, $3) }
  | LIDENT COLON UIDENT    { ($1, $3) }

// =================================================
// Multiple variable declarations.
// "x : int, ud: UserData"
// =================================================
varDecls:
  | varDecl  { List.singleton $1 }
  | varDecl SEMICOLON varDecls  { $1 :: $3 }

// =================================================
// A single constructor argument.
// "x : int", "string"
// =================================================
ctorArg:
  | LIDENT COLON UIDENT   { ($1, $3) }
  | LIDENT                { ("", $1) }
  | UIDENT                { ("", $1) }

// =================================================
// A series of constructor arguments.
// "x : int * y: string * UserData"
// =================================================
ctorArgs:
  | ctorArg { List.singleton $1 }
  | ctorArg STAR ctorArgs  { $1 :: $3 }

// =================================================
// A single SumType constructor
// "| Circle"
// "| Point int * int * int"
// =================================================
sumtypeCtor:
  | VBAR UIDENT { ($2, []) }
  | VBAR UIDENT OF ctorArgs { ($2, $4) }

// =================================================
// A series of constructors.
// "| Circle | Point int * int * int"
// =================================================
sumtypeCtors:
  | sumtypeCtor  { List.singleton $1 }
  | sumtypeCtor sumtypeCtors { $1 :: $2 }

// =================================================
// A sumtype is a series of constructors.
// =================================================
sumType:
  | sumtypeCtors  { SumType $1 }

// =================================================
// A product type is defined as a possibly empty list
//  of variable declarations enclosed in braces.
// "{ a:int, b:string }"
// "{ }"    (empty record)
// =================================================
prodType:
  | LEFT_BRACE RIGHT_BRACE { ProdType [] }
  | LEFT_BRACE varDecls RIGHT_BRACE  { ProdType ($2) }

// =================================================
// Function and Handler argument
// "(x:int)" "y"
// =================================================
funcArg:
  | LEFT_BRACKET varDecl RIGHT_BRACKET { $2 }
  | LIDENT  { ($1, "") }

funcArgs:
  | funcArg   { List.singleton $1 }
  | funcArg funcArgs { $1 :: $2 }

// =================================================
// Language expression is a recursive structure that
// may be one of the following:
// =================================================
expr:
  | INT                                 { ENum ( $1 |> int ) }
  | LIDENT                              { EVar $1 }
  | LEFT_BRACKET expr RIGHT_BRACKET     { $2 }
  | expr GT expr                        { EGt ($1, $3)  }
  | expr PLUS expr                      { EAdd ($1, $3) }
  | expr MINUS expr                     { ESub ($1, $3) }
  | expr STAR expr                      { EMul ($1, $3) }
  | IF expr THEN expr ELSE expr         { EIf ($2, $4, $6) }
  | LET LIDENT EQ expr IN expr          { ELet (false, [($2, $4)], $6)                   }
  | LET LIDENT funcArgs EQ expr IN expr
     {
       let argNames = List.map fst $3
       ELet (false, [($2, unfoldFunction argNames $5)], $7)
     }
  | expr expr                           { EAp ($1, $2) }

exprs:
  | { [] }
  | expr exprs { $1 :: $2 }

// =================================================
// Declaration is one of the following:
//  datatype definition
//  handler definition
//  etc.
// =================================================
decl:
  | TYPEDEF UIDENT EQ prodType  { TypeDef ($2, $4) }
  | TYPEDEF UIDENT EQ sumType   { TypeDef ($2, $4) }
  | HANDLER LIDENT funcArgs EQ expr { HandlerDef ($2, $3, $5) }

// List of declarations
decls:
  | { [] }
  | decl decls    { $1 :: $2 }

// Module is a named list of declarations.
modle:
  | MODULE LIDENT decls { Module ($2, $3) }
