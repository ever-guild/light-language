%{
open ParserModule
open type LHMachine.Expr

// EFunc of arg:Name * body:Expr
// ["x","y","z"], body ->
//   --> EFunc ("x", EFunc ("y", EFunc ("z", body)))
let rec unfoldFunction args body =
    match args with
    | [x] ->
        EFunc (x, body)
    | h :: t ->
        EFunc (h, unfoldFunction t body)
%}

%start start

%token <int> INT
%token <string> UIDENT  // uppercase identifier
%token <string> LIDENT  // lowercase identifier
%token <string> IDENT    // variable type
%token <string> STRING
%token MODULE
%token TYPEDEF
%token OF
%token IF
%token THEN
%token ELSE
%token HANDLER
%token LET
%token RECURSIVE
%token IN
%token EQ
%token GT
%token PLUS
%token MINUS
%token SEMICOLON
%token VBAR
%token STAR
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token COLON
%token COMMA
%token EOF

%type <ParserModule.Module option> start

%%

start:
  | EOF { None }
  | modle { Some $1 }

// =================================================
// Single variable declaration.
// "x : int", "ud : UserData"
// =================================================
varDecl:
  | LIDENT COLON LIDENT    { ($1, $3) }
  | LIDENT COLON UIDENT    { ($1, $3) }

// =================================================
// Multiple variable declarations.
// "x : int, ud: UserData"
// =================================================
varDecls:
  | varDecl  { List.singleton $1 }
  | varDecl SEMICOLON varDecls  { $1 :: $3 }

// =================================================
// A single constructor argument.
// "x : int", "string"
// =================================================
ctorArg:
  | LIDENT COLON UIDENT   { ($1, $3) }
  | LIDENT                { ("", $1) }
  | UIDENT                { ("", $1) }

// =================================================
// A series of constructor arguments.
// "x : int * y: string * UserData"
// =================================================
ctorArgs:
  | ctorArg { List.singleton $1 }
  | ctorArg STAR ctorArgs  { $1 :: $3 }

// =================================================
// A single SumType constructor
// "| Circle"
// "| Point int * int * int"
// =================================================
sumtypeCtor:
  | VBAR UIDENT { ($2, []) }
  | VBAR UIDENT OF ctorArgs { ($2, $4) }

// =================================================
// A series of constructors.
// "| Circle | Point int * int * int"
// =================================================
sumtypeCtors:
  | sumtypeCtor  { List.singleton $1 }
  | sumtypeCtor sumtypeCtors { $1 :: $2 }

// =================================================
// A sumtype is a series of constructors.
// =================================================
sumType:
  | sumtypeCtors  { SumType $1 }

// =================================================
// A product type is defined as a possibly empty list
//  of variable declarations enclosed in braces.
// "{ a:int, b:string }"
// "{ }"    (empty record)
// =================================================
prodType:
  | LEFT_BRACE RIGHT_BRACE { ProdType [] }
  | LEFT_BRACE varDecls RIGHT_BRACE  { ProdType ($2) }

// =================================================
// Function and Handler argument
// "(x:int)" "y"
// =================================================
funcArg:
  | LEFT_BRACKET varDecl RIGHT_BRACKET { $2 }
  | LIDENT  { ($1, "") }

funcArgs:
  | funcArg   { List.singleton $1 }
  | funcArg funcArgs { $1 :: $2 }

// =================================================
// Language expression is a recursive structure that
// may be one of the following:
// =================================================
expr:
  | INT                         { ENum ( $1 |> int ) }
  | LIDENT                      { EVar $1 }
  | LEFT_BRACKET expr RIGHT_BRACKET { $2 }
  | expr GT expr                { EGt ($1, $3) }
  | expr PLUS expr              { EAdd ($1, $3) }
  | expr MINUS expr             { ESub ($1, $3) }
  | expr STAR expr              { EMul ($1, $3) }
  | IF expr THEN expr ELSE expr { EIf ($2, $4, $6) }
  | LET LIDENT EQ expr IN expr  { ELet (false, [($2,$4)], $6) }
  | expr expr                   { EAp ($1, $2) }



// =================================================
// Declaration is one of the following:
//  datatype definition
//  handler definition
//  etc.
// =================================================
decl:
  | TYPEDEF UIDENT EQ prodType  { TypeDef ($2, $4) }
  | TYPEDEF UIDENT EQ sumType   { TypeDef ($2, $4) }
  | HANDLER LIDENT funcArgs EQ expr { HandlerDef ($2, $3, $5) }

// List of declarations
decls:
  | { [] }
  | decl decls    { $1 :: $2 }

// Module is a named list of declarations.
modle:
  | MODULE LIDENT decls { Module ($2, $3) }
