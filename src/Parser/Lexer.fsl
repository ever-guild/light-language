{
module Lexer

open FSharp.Text.Lexing
open System
open Parser

exception SyntaxError of string

let lexeme = LexBuffer<_>.LexemeString

let newline (lexbuf: LexBuffer<_>) =
  lexbuf.StartPos <- lexbuf.StartPos.NextLine
}

let int = ['-' '+']? ['0'-'9']+
let digit = ['0'-'9']
let ucase = ['A'-'Z']
let lcase = ['a'-'z']
let ucaseIdentifier = ucase (lcase | digit | ucase | '_' | '\'' )*
let lcaseIdentifier = lcase (ucase | digit | lcase | '_' | '\'' )*
let identifier = lcaseIdentifier | ucaseIdentifier

let white = [' ' '\t']+
let newline = '\r' | '\n' | "\r\n"

rule read =
  parse
  | white    { read lexbuf }
  | newline  { newline lexbuf; read lexbuf }
  | int      { INT (int (lexeme lexbuf)) }
  | "contract" { MODULE }
  | "type"   { TYPEDEF }
  | "of"     { OF }
  | "handler" { HANDLER }
  | "if"     { IF }
  | "then"   { THEN }
  | "else"   { ELSE }
  | "let"    { LET }
  | "rec"    { RECURSIVE }
  | "in"     { IN }
  | "match"  { MATCH }
  | "with"   { WITH }
  | ucaseIdentifier  { UIDENT (string (lexeme lexbuf)) }
  | lcaseIdentifier  { LIDENT (string (lexeme lexbuf)) }
  | identifier { IDENT (string (lexeme lexbuf)) }
  | ";;"     { DSCOLON }
  | "->"     { RARROW  }  // function type
  | "<-"     { LARROW  }  // assignment operator
  | '"'      { read_string "" false lexbuf }
  | '{'      { LEFT_BRACE }
  | '}'      { RIGHT_BRACE }
  | '('      { LPAREN }
  | ')'      { RPAREN }
  | '|'      { VBAR }
  | ':'      { COLON }
  | '.'      { DOT }
  | '*'      { STAR }
  | ','      { COMMA }
  | ';'      { SEMICOLON }
  | '='      { EQ }
  | '+'      { PLUS }
  | '-'      { MINUS }
  | '>'      { GT }
  | '_'      { UNDERSCORE }
  | eof      { EOF }
  | _
     {
      raise (Exception (sprintf "SyntaxError: Unexpected char: '%s' Line: %d Column: %d"
                           (lexeme lexbuf)
                           (lexbuf.StartPos.Line+1)
                           lexbuf.StartPos.Column))
     }


and read_string str ignorequote =
  parse
  | '"'           { if ignorequote  then (read_string (str+"\\\"") false lexbuf) else STRING (str) }
  | '\\'          { read_string str true lexbuf }
  | [^ '"' '\\']+ { read_string (str+(lexeme lexbuf)) false lexbuf }
  | eof           { raise (Exception ("String is not terminated")) }
