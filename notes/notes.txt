// Description:
//    This file contains random notes on the topic of Lighthouse language.
// Author:
//    Evgeniy Shishkin <evgeniy.shishkin@gmail.com>
// Date:
//    Jan 2023

Содержимое стека на момент передачи управления в контракт:
* acc_balance
* msg_balance
* in_msg_cell
* in_msg_body_slice
* is_ext_msg

Самый последний элемент - признак внешнего сообщения - находится
на вершине стека.

Код для загрузки нужного обработчика:

OVER               // PUSH 1: msg_body_slice
LDU 32             // n s'
SWAP               // s' n
PUSHINT 32         // s' n 32
SWAP               // s' 32 n
handlers GETGLOB   // s' 32 n D
SWAP               // s' 32 D n
DICTUGETEXEC       // 

Далее, обработчик загружает и сам парсит аргумент из s' для своего тела.
Компилятор вставляет текст этого парсера, исходя из типов аргументов,
принимаемых обработчиком.

** Обработчик отправляет сообщения и изменяет состояние контракта

По-мимо вычислений, обработчик отправляет сообщения и меняет состояние
контракта. В качестве типа возвращаемого значения указан unit.

** Параметры для обработчика сообщений

Предположим, есть обработчик:
handler add_more (x:int) =
  ...

Это  сокращенная форма  записи.  На самом  деле, обработчик  принимает
такие параметры:

handler add_more (msg:Message) (state:State) (x:int) =
 ...

или, аналогично,

handler add_more msg state x =
 ...

Первые две переменные - стандартные для всех обработчиков, поэтому они
по  умолчанию  скрываются  из  списка параметров.  Их,  однако,  можно
указать при желании. Тип обработчика отражает параметры:

add_more: Message -> State -> int -> unit


Альтернативный формат передачи всей этой служебной информации:

add_more: Context -> int -> unit

type Context = {
  msg: Message;
  state: State;
  acc_balance: NanoGrams;
}

Тогда везде нужно писать:
 ctx.msg.src;
 ctx.msg.dest;
 ctx.acc_balance;

и определить вспомогательные функции:
 now(), acc_balance() ...

