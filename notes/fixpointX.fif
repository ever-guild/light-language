"Asm.fif" include

<{

 // Fixpoint operator.
 // let fix f =
 //   let rec g x1 .. xn = f g x1 .. xn
 //   in g

 // Input:
 // f g' x1 .. xn   (g' does not contain f on stack)
 // Output:
 // (f g x1 .. xn)  i.e. result of applying f to g and x1 .. xn
 <{
   <{
     DUMPSTK
                    // g stack:
                    // f g' x1 .. xn   // g' does not contain f on stack
     DEPTH          // f g' x1 .. xn n+2
     -2 ADDCONST    // f g' x1 .. xn n
     TUPLEVAR       // f g' (x1 .. xn)  // arguments packed into a tuple
     // So we reduced the problem to a fixpoint with a single argument modulo
     // unpacking the arguments before application
     s2 PUSH        // f g' x f   // so we need to setup the g stack properly
     s2 PUSH        // f g' x f g'
     DUP            // f g' x f g' g'
     2 -1 SETCONTARGS // f g x g''
     s0 s2 XCHG     // f g'' x g'
     DROP           // f g'' x   , from now on, we assume g=g''
     s1 s2 XCHG     // g f x
     DUMPSTK
     15 EXPLODE     // g f x1 .. xn n
     DUMPSTK
     ROLLX          // g x1 .. xn f
     DEPTH          // g x1 .. xn f n+2
     DEC            // g x1 .. xn f n+1     (f takes (g x1 .. xn) as arguments)
     TRUE           // g x1 .. xn f n+2 -1  (f may return something)
     DUMPSTK
     CALLXVARARGS  // (f g x1 .. xn)
   }> PUSHCONT      // f g
   DUP              // f g g
   2 -1 SETCONTARGS  // g' (f g is put on the stack of g')
 }> PUSHCONT
 2 SETGLOB    // global[2] = FIX operator

 // let rec sub n = if n > 1 then sub (n-1) else 1
 // let sub = fix (\sub -> \n -> if n > 1 then (sub (n-1)) else 1)
 10 INT
 20 INT

 // sum f n m = f (n+1) (m+1)
 <{
    // "inc" PRINTSTR
    DUMPSTK      // f n m
    s1 PUSH      // f n m
    1 INT
    ADD          // f n (n+1)
    s1 PUSH
    1 INT
    ADD          // f n m (n+1) (m+1)
    s4 PUSH      // f n m (n+1) (m+1) f
    DUMPSTK
    2 1 CALLXARGS  // f n m (f (n+1) (m+1))
    NIP
    NIP
 }> PUSHCONT

 // let main = (fix inc) 10
 // Замена LetRec на Fix (Let ...) происходит в месте вызова функции.
 2 GETGLOB     // f' fix
 1 1 CALLXARGS // [fix f']
 2 1 CALLXARGS
}>s runvmcode .s